const StudyPlan = require('../models/StudyPlan');
const Subject = require('../models/Subject');
const Task = require('../models/Task');
const Timetable = require('../models/Timetable');
const User = require('../models/User');

// Helper function to get day name
const getDayName = (date) => {
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  return days[date.getDay()];
};

// @desc    Generate smart study plan for a date
// @route   POST /api/studyplan/generate
// @access  Private
const generateStudyPlan = async (req, res) => {
  try {
    const { date } = req.body;
    const planDate = date ? new Date(date) : new Date();
    planDate.setHours(0, 0, 0, 0);

    const user = await User.findById(req.user._id);
    const dayName = getDayName(planDate);

    // Get all data needed for smart planning
    const [subjects, tasks, timetable] = await Promise.all([
      Subject.find({ userId: req.user._id }),
      Task.find({ 
        userId: req.user._id, 
        status: { $ne: 'done' },
        deadline: { $gte: planDate }
      }).sort({ deadline: 1 }),
      Timetable.find({ 
        userId: req.user._id, 
        day: dayName,
        isActive: true 
      }).sort({ startTime: 1 })
    ]);

    // Calculate free slots
    const freeSlots = calculateFreeSlots(timetable);

    // Prioritize subjects based on:
    // 1. Low attendance (< threshold)
    // 2. Upcoming exams
    // 3. Assignments due soon
    const prioritizedSubjects = prioritizeSubjects(
      subjects, 
      tasks, 
      user.attendanceCriteria
    );

    // Generate study blocks
    const studyBlocks = [];
    let remainingSlots = [...freeSlots];

    for (const subject of prioritizedSubjects) {
      if (remainingSlots.length === 0) break;

      // Determine study duration based on priority
      const duration = getStudyDuration(subject);
      
      for (let i = 0; i < remainingSlots.length; i++) {
        const slot = remainingSlots[i];
        
        if (slot.duration >= duration) {
          // Find related tasks for this subject
          const relatedTask = tasks.find(t => 
            t.subjectId && t.subjectId.toString() === subject._id.toString()
          );

          studyBlocks.push({
            subjectId: subject._id,
            startTime: slot.startTime,
            endTime: addMinutesToTime(slot.startTime, duration),
            duration,
            topic: relatedTask ? relatedTask.title : `Study ${subject.subjectName}`,
            priority: subject.priority,
            isCompleted: false
          });

          // Update remaining slot
          if (slot.duration > duration) {
            remainingSlots[i] = {
              startTime: addMinutesToTime(slot.startTime, duration),
              endTime: slot.endTime,
              duration: slot.duration - duration
            };
          } else {
            remainingSlots.splice(i, 1);
          }
          
          break;
        }
      }
    }

    // Check if plan already exists for this date
    let studyPlan = await StudyPlan.findOne({ 
      userId: req.user._id,
      date: planDate 
    });

    if (studyPlan) {
      studyPlan.studyBlocks = studyBlocks;
      studyPlan.isAutoGenerated = true;
      await studyPlan.save();
    } else {
      studyPlan = await StudyPlan.create({
        userId: req.user._id,
        date: planDate,
        studyBlocks,
        isAutoGenerated: true
      });
    }

    const populatedPlan = await StudyPlan.findById(studyPlan._id)
      .populate('studyBlocks.subjectId');

    res.json({
      success: true,
      data: populatedPlan
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// Helper: Calculate free slots from timetable
function calculateFreeSlots(timetable) {
  const timeToMinutes = (time) => {
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
  };

  const freeSlots = [];
  const dayStart = '08:00';
  const dayEnd = '20:00';

  if (timetable.length === 0) {
    return [{ startTime: dayStart, endTime: dayEnd, duration: 720 }];
  }

  // Before first class
  if (timetable[0].startTime > dayStart) {
    const duration = timeToMinutes(timetable[0].startTime) - timeToMinutes(dayStart);
    if (duration >= 30) {
      freeSlots.push({ startTime: dayStart, endTime: timetable[0].startTime, duration });
    }
  }

  // Between classes
  for (let i = 0; i < timetable.length - 1; i++) {
    const gapStart = timetable[i].endTime;
    const gapEnd = timetable[i + 1].startTime;
    const duration = timeToMinutes(gapEnd) - timeToMinutes(gapStart);
    
    if (duration >= 30) {
      freeSlots.push({ startTime: gapStart, endTime: gapEnd, duration });
    }
  }

  // After last class
  const lastClass = timetable[timetable.length - 1];
  if (lastClass.endTime < dayEnd) {
    const duration = timeToMinutes(dayEnd) - timeToMinutes(lastClass.endTime);
    if (duration >= 30) {
      freeSlots.push({ startTime: lastClass.endTime, endTime: dayEnd, duration });
    }
  }

  return freeSlots;
}

// Helper: Prioritize subjects
function prioritizeSubjects(subjects, tasks, attendanceCriteria) {
  return subjects.map(subject => {
    let priorityScore = 0;
    let priority = 'medium';

    // Low attendance increases priority
    const attendancePerc = subject.totalClasses > 0 
      ? (subject.attendedClasses / subject.totalClasses) * 100 
      : 100;
    
    if (attendancePerc < attendanceCriteria) {
      priorityScore += 30;
      priority = 'high';
    }

    // Upcoming tasks increase priority
    const urgentTasks = tasks.filter(t => 
      t.subjectId && 
      t.subjectId.toString() === subject._id.toString() &&
      t.daysUntilDeadline <= 7
    );

    if (urgentTasks.length > 0) {
      priorityScore += urgentTasks.length * 10;
      priority = 'high';
    }

    return {
      ...subject.toObject(),
      priorityScore,
      priority
    };
  }).sort((a, b) => b.priorityScore - a.priorityScore);
}

// Helper: Get study duration based on priority
function getStudyDuration(subject) {
  if (subject.priority === 'high') return 90; // 1.5 hours
  if (subject.priority === 'medium') return 60; // 1 hour
  return 45; // 45 minutes
}

// Helper: Add minutes to time string
function addMinutesToTime(time, minutes) {
  const [hours, mins] = time.split(':').map(Number);
  const totalMinutes = hours * 60 + mins + minutes;
  const newHours = Math.floor(totalMinutes / 60);
  const newMins = totalMinutes % 60;
  return `${String(newHours).padStart(2, '0')}:${String(newMins).padStart(2, '0')}`;
}

// @desc    Get study plan for a date
// @route   GET /api/studyplan/:date
// @access  Private
const getStudyPlan = async (req, res) => {
  try {
    const planDate = new Date(req.params.date);
    planDate.setHours(0, 0, 0, 0);

    const studyPlan = await StudyPlan.findOne({ 
      userId: req.user._id,
      date: planDate 
    }).populate('studyBlocks.subjectId');

    if (!studyPlan) {
      return res.status(404).json({
        success: false,
        message: 'No study plan found for this date'
      });
    }

    res.json({
      success: true,
      data: studyPlan
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

// @desc    Update study block completion
// @route   PUT /api/studyplan/:id/block/:blockIndex
// @access  Private
const updateStudyBlock = async (req, res) => {
  try {
    const { id, blockIndex } = req.params;
    const { isCompleted } = req.body;

    const studyPlan = await StudyPlan.findById(id);

    if (!studyPlan) {
      return res.status(404).json({
        success: false,
        message: 'Study plan not found'
      });
    }

    if (studyPlan.userId.toString() !== req.user._id.toString()) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized'
      });
    }

    if (blockIndex < 0 || blockIndex >= studyPlan.studyBlocks.length) {
      return res.status(400).json({
        success: false,
        message: 'Invalid block index'
      });
    }

    studyPlan.studyBlocks[blockIndex].isCompleted = isCompleted;
    await studyPlan.save();

    const populatedPlan = await StudyPlan.findById(studyPlan._id)
      .populate('studyBlocks.subjectId');

    res.json({
      success: true,
      data: populatedPlan
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message
    });
  }
};

module.exports = {
  generateStudyPlan,
  getStudyPlan,
  updateStudyBlock
};
